package de.katzenpapst.amunra.client.gui;

import java.nio.FloatBuffer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;

import micdoodle8.mods.galacticraft.api.event.client.CelestialBodyRenderEvent;
import micdoodle8.mods.galacticraft.api.galaxies.CelestialBody;
import micdoodle8.mods.galacticraft.api.galaxies.GalaxyRegistry;
import micdoodle8.mods.galacticraft.api.galaxies.IChildBody;
import micdoodle8.mods.galacticraft.api.galaxies.Moon;
import micdoodle8.mods.galacticraft.api.galaxies.Planet;
import micdoodle8.mods.galacticraft.api.galaxies.SolarSystem;
import micdoodle8.mods.galacticraft.api.galaxies.Star;
import micdoodle8.mods.galacticraft.core.client.gui.screen.GuiCelestialSelection;
import micdoodle8.mods.galacticraft.core.util.ColorUtil;
import micdoodle8.mods.galacticraft.core.util.GCCoreUtil;

import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.MinecraftForge;

import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.util.vector.Matrix4f;
import org.lwjgl.util.vector.Vector2f;
import org.lwjgl.util.vector.Vector3f;

import de.katzenpapst.amunra.AmunRa;
import de.katzenpapst.amunra.helper.ShuttleTeleportHelper;
import de.katzenpapst.amunra.mothership.Mothership;
import de.katzenpapst.amunra.mothership.MothershipWorldData;
import de.katzenpapst.amunra.tick.TickHandlerServer;
import de.katzenpapst.amunra.vec.BoxInt2D;

public class GuiARCelestialSelection extends GuiCelestialSelection {

    public static ResourceLocation guiExtra = new ResourceLocation(
            AmunRa.ASSETPREFIX,
            "textures/gui/celestialselection_extra.png");

    protected int numPlayersMotherships = -1;

    // the body where the player has started from, or the mothership's parent, if player started from a MS
    // can be null
    protected CelestialBody playerParent = null;

    protected CelestialBody lastSelectedBodyMS;

    protected CelestialBody nextSelectedBody = null;

    protected List<CelestialBody> shuttlePossibleBodies;

    protected boolean isMessageShown = false;

    protected String messageCaption = "";
    protected String messageText = "";

    protected BoxInt2D messageButtonBox = new BoxInt2D();

    public GuiARCelestialSelection(boolean mapMode, List<CelestialBody> possibleBodies) {
        super(mapMode, possibleBodies);
        shuttlePossibleBodies = possibleBodies;
    }

    public void setPossibleBodies(List<CelestialBody> possibleBodies) {
        this.possibleBodies = possibleBodies;
        this.shuttlePossibleBodies = possibleBodies;
    }

    @Override
    public void initGui() {
        super.initGui();

        // do stuff
        MothershipWorldData msData = TickHandlerServer.mothershipData;
        for (Mothership ms : msData.getMotherships().values()) {
            this.celestialBodyTicks.put(ms, 0);
        }

        updateNumPlayerMotherships();
        updatePlayerParent();
    }

    protected boolean isMouseWithin(int mouseX, int mouseY, int rectX, int rectY, int rectW, int rectH) {
        return mouseX >= rectX && mouseX <= rectX + rectW && mouseY >= rectY && mouseY <= rectY + rectH;
    }

    @Override
    public void drawButtons(int mousePosX, int mousePosY) {
        super.drawButtons(mousePosX, mousePosY);
        if (this.isMessageShown) {
            drawMessageBox();
        }
    }

    protected void drawMessageBox() {
        GL11.glPushMatrix();

        GL11.glColor4f(0.0F, 0.6F, 1.0F, 1);

        this.mc.renderEngine.bindTexture(guiExtra);

        // box
        int boxWidth = 179;
        int boxHeight = 67;
        this.drawTexturedModalRect(
                (width - boxWidth) / 2,
                (height - boxHeight) / 2,
                boxWidth,
                boxHeight,
                0,
                135, // u/v position
                boxWidth,
                boxHeight, // u/v size
                true,
                false);

        int btnOffset = 24;

        int btnWidth = 93;
        int btnHeight = 12;

        messageButtonBox
                .setPositionSize((width - btnWidth) / 2, (height - btnHeight) / 2 + btnOffset, btnWidth, btnHeight);

        GL11.glColor4f(0.0F, 1.0F, 0.0F, 1);
        this.drawTexturedModalRect(
                messageButtonBox.minX,
                messageButtonBox.minY,
                messageButtonBox.getWidth(),
                messageButtonBox.getHeight(),
                0,
                202, // u/v position
                93,
                12, // u/v size
                true,
                false);
        String str = messageCaption;
        this.fontRendererObj.drawString(
                str,
                (width - fontRendererObj.getStringWidth(str)) / 2,
                (height - boxHeight) / 2 + 3,
                ColorUtil.to32BitColor(255, 255, 255, 255));

        str = GCCoreUtil.translate("gui.message.mothership.okay");
        this.fontRendererObj.drawString(
                str,
                (width - fontRendererObj.getStringWidth(str)) / 2,
                (height - btnHeight) / 2 + 2 + btnOffset,
                ColorUtil.to32BitColor(255, 255, 255, 255));

        // this.drawSplitString(GCCoreUtil.translate("gui.message.clickAgain.0.name"), width -
        // GuiCelestialSelection.BORDER_WIDTH - GuiCelestialSelection.BORDER_EDGE_WIDTH - 182 + 41,
        // GuiCelestialSelection.BORDER_WIDTH + GuiCelestialSelection.BORDER_EDGE_WIDTH + 1 - 38 + sliderPos, 79,
        // ColorUtil.to32BitColor(255, 150, 150, 150), false, false);
        this.fontRendererObj.drawSplitString(
                messageText,
                (width - boxWidth) / 2 + 4,
                (height - boxHeight) / 2 + 14,
                boxWidth - 8,
                ColorUtil.to32BitColor(255, 255, 255, 255));

        GL11.glPopMatrix();
    }

    protected void showTooltip(String text, int mousePosX, int mousePosY) {
        GL11.glDepthMask(true);
        GL11.glEnable(GL11.GL_DEPTH_TEST);
        GL11.glPushMatrix();
        GL11.glTranslatef(0, 0, 300);
        int stringWidth = this.smallFontRenderer.getStringWidth(text);
        int tooltipX = mousePosX - stringWidth / 2;
        int tooltipY = mousePosY - 12;
        int widhtOffsetOrSo = 8;

        if (tooltipX + stringWidth > this.width) {
            tooltipX -= (tooltipX - this.width + stringWidth);
        }

        if (tooltipY + widhtOffsetOrSo + 6 > this.height) {
            tooltipY = this.height - widhtOffsetOrSo - 6;
        }

        int j1 = ColorUtil.to32BitColor(190, 0, 153, 255);
        this.drawGradientRect(tooltipX - 3, tooltipY - 4, tooltipX + stringWidth + 3, tooltipY - 3, j1, j1);
        this.drawGradientRect(
                tooltipX - 3,
                tooltipY + widhtOffsetOrSo + 3,
                tooltipX + stringWidth + 3,
                tooltipY + widhtOffsetOrSo + 4,
                j1,
                j1);
        this.drawGradientRect(
                tooltipX - 3,
                tooltipY - 3,
                tooltipX + stringWidth + 3,
                tooltipY + widhtOffsetOrSo + 3,
                j1,
                j1);
        this.drawGradientRect(tooltipX - 4, tooltipY - 3, tooltipX - 3, tooltipY + widhtOffsetOrSo + 3, j1, j1);
        this.drawGradientRect(
                tooltipX + stringWidth + 3,
                tooltipY - 3,
                tooltipX + stringWidth + 4,
                tooltipY + widhtOffsetOrSo + 3,
                j1,
                j1);
        int k1 = ColorUtil.to32BitColor(170, 0, 153, 255);
        int l1 = (k1 & 16711422) >> 1 | k1 & -16777216;
        this.drawGradientRect(
                tooltipX - 3,
                tooltipY - 3 + 1,
                tooltipX - 3 + 1,
                tooltipY + widhtOffsetOrSo + 3 - 1,
                k1,
                l1);
        this.drawGradientRect(
                tooltipX + stringWidth + 2,
                tooltipY - 3 + 1,
                tooltipX + stringWidth + 3,
                tooltipY + widhtOffsetOrSo + 3 - 1,
                k1,
                l1);
        this.drawGradientRect(tooltipX - 3, tooltipY - 3, tooltipX + stringWidth + 3, tooltipY - 3 + 1, k1, k1);
        this.drawGradientRect(
                tooltipX - 3,
                tooltipY + widhtOffsetOrSo + 2,
                tooltipX + stringWidth + 3,
                tooltipY + widhtOffsetOrSo + 3,
                l1,
                l1);

        this.smallFontRenderer.drawString(text, tooltipX, tooltipY, ColorUtil.to32BitColor(255, 255, 255, 255));

        GL11.glPopMatrix();
    }

    protected boolean isSiblingOf(CelestialBody celestialBody, Mothership ship) {
        if (celestialBody instanceof Planet) {
            SolarSystem solarSystem = ((Planet) celestialBody).getParentSolarSystem();
            return solarSystem.getMainStar().equals(ship.getParent());
        } else if (celestialBody instanceof IChildBody) {
            Planet planet = ((IChildBody) celestialBody).getParentPlanet();

            return planet.equals(ship.getParent());
        } else if (celestialBody instanceof Mothership) {
            ((Mothership) celestialBody).getParent().equals(ship.getParent());
        }

        return false;
    }

    protected List<Mothership> getMothershipListToRender() {
        LinkedList<Mothership> result = new LinkedList<Mothership>();

        if (this.selectedBody != null) {
            MothershipWorldData msData = TickHandlerServer.mothershipData;

            for (Mothership ms : msData.getMotherships().values()) {
                if ((ms == this.selectedBody || (ms.getParent() == this.selectedBody && this.selectionCount != 1))
                        && (this.ticksSinceSelection > 35 || this.selectedBody == ms
                                || (this.lastSelectedBody instanceof Mothership
                                        && ((Mothership) this.lastSelectedBody).getParent().equals(ms)
                                // GalaxyRegistry.getMoonsForPlanet(((Moon)
                                // this.lastSelectedBody).getParentPlanet()).contains(moon)
                                )) || isSiblingOf(this.selectedBody, ms)) {
                    result.add(ms);
                }
            }
        }

        return result;
    }

    protected CelestialBody getBodyToRenderMothershipsAround() {

        if (this.selectedBody instanceof Star) {
            if (selectionCount != 1 && this.ticksSinceSelection > 35) {
                return this.selectedBody;
            }
            return null;
        }
        if (this.selectedBody instanceof Planet) {
            // ship's parent is the body and selectionCount != 1
            // AND
            // this.ticksSinceSelection > 35
            if (selectionCount != 1 && this.ticksSinceSelection > 35) {
                return this.selectedBody;
            }
            return null;
        } else if (this.selectedBody instanceof IChildBody) {
            if (selectionCount != 1 && this.ticksSinceSelection > 35) {
                return this.selectedBody;
            }
            return null;
            // renderShipsAround = ((IChildBody)this.selectedBody).getParentPlanet();
            // I almost think never TODO find out
        } else if (this.selectedBody instanceof Mothership) {
            return ((Mothership) this.selectedBody).getParent();
        }
        return null;
    }

    protected void _workaroundDrawMoon(Matrix4f worldMatrix0, Moon moon, FloatBuffer fb,
            HashMap<CelestialBody, Matrix4f> matrixMap) {
        GL11.glPushMatrix();
        Matrix4f worldMatrix1 = new Matrix4f(worldMatrix0);
        Matrix4f.translate(this.getCelestialBodyPosition(moon), worldMatrix1, worldMatrix1);

        Matrix4f worldMatrix2 = new Matrix4f();
        Matrix4f.rotate((float) Math.toRadians(45), new Vector3f(0, 0, 1), worldMatrix2, worldMatrix2);
        Matrix4f.rotate((float) Math.toRadians(-55), new Vector3f(1, 0, 0), worldMatrix2, worldMatrix2);
        Matrix4f.scale(new Vector3f(0.25F, 0.25F, 1.0F), worldMatrix2, worldMatrix2);
        worldMatrix2 = Matrix4f.mul(worldMatrix1, worldMatrix2, worldMatrix2);

        fb.rewind();
        worldMatrix2.store(fb);
        fb.flip();
        GL11.glMultMatrix(fb);

        CelestialBodyRenderEvent.Pre preEvent = new CelestialBodyRenderEvent.Pre(moon, moon.getBodyIcon(), 8);
        MinecraftForge.EVENT_BUS.post(preEvent);

        GL11.glColor4f(1, 1, 1, 1);
        if (preEvent.celestialBodyTexture != null) {
            this.mc.renderEngine.bindTexture(preEvent.celestialBodyTexture);
        }

        if (!preEvent.isCanceled()) {
            int size = this.getWidthForCelestialBodyStatic(moon);
            this.drawTexturedModalRect(
                    -size / 2,
                    -size / 2,
                    size,
                    size,
                    0,
                    0,
                    preEvent.textureSize,
                    preEvent.textureSize,
                    false,
                    false,
                    preEvent.textureSize,
                    preEvent.textureSize);
            matrixMap.put(moon, worldMatrix1);
        }

        CelestialBodyRenderEvent.Post postEvent = new CelestialBodyRenderEvent.Post(moon);
        MinecraftForge.EVENT_BUS.post(postEvent);
        fb.clear();
        GL11.glPopMatrix();
    }

    protected void _workaroundDrawMoonCircle(Moon moon, float sin, float cos) {
        float x = this.getScale(moon);
        float y = 0;

        float alpha = 1;

        GL11.glPushMatrix();
        Vector3f planetPos = this.getCelestialBodyPosition(moon.getParentPlanet());
        GL11.glTranslatef(planetPos.x, planetPos.y, 0);

        if (this.selectionCount >= 2) {
            alpha = this.selectedBody instanceof IChildBody ? 1.0F
                    : Math.min(Math.max((this.ticksSinceSelection - 30) / 15.0F, 0.0F), 1.0F);

            if (this.lastSelectedBody instanceof Moon) {
                if (GalaxyRegistry.getMoonsForPlanet(((Moon) this.lastSelectedBody).getParentPlanet()).contains(moon)) {
                    alpha = 1.0F;
                }
            }
        }

        if (alpha != 0) {
            /*
             * switch (count % 2) { case 0: GL11.glColor4f(0.0F, 0.6F, 1.0F, alpha); break; case 1:
             */
            GL11.glColor4f(0.4F, 0.9F, 1.0F, alpha);
            /*
             * break; }
             */

            CelestialBodyRenderEvent.CelestialRingRenderEvent.Pre preEvent = new CelestialBodyRenderEvent.CelestialRingRenderEvent.Pre(
                    moon,
                    new Vector3f(0.0F, 0.0F, 0.0F));
            MinecraftForge.EVENT_BUS.post(preEvent);

            if (!preEvent.isCanceled()) {
                GL11.glBegin(GL11.GL_LINE_LOOP);

                float temp;
                for (int i = 0; i < 90; i++) {
                    GL11.glVertex2f(x, y);

                    temp = x;
                    x = cos * x - sin * y;
                    y = sin * temp + cos * y;
                }

                GL11.glEnd();

                // count++;
            }

            CelestialBodyRenderEvent.CelestialRingRenderEvent.Post postEvent = new CelestialBodyRenderEvent.CelestialRingRenderEvent.Post(
                    moon);
            MinecraftForge.EVENT_BUS.post(postEvent);
        }
        GL11.glPopMatrix();
    }

    @Override
    public void drawCircles() {

        // do the motherships first, because I have no idea where the matrix will be after the super call
        GL11.glPushMatrix();

        GL11.glLineWidth(3);

        final float theta = (float) (2 * Math.PI / 90);
        final float cos = (float) Math.cos(theta);
        final float sin = (float) Math.sin(theta);

        CelestialBody body = getBodyToRenderMothershipsAround();
        if (body instanceof Moon && this.selectionCount >= 1) { // TODO add condition to figure out if stuff
            this._workaroundDrawMoonCircle((Moon) body, sin, cos);
        }
        GL11.glColor4f(0.6F, 0.2F, 0.2F, 0.8F);
        if (body != null) {
            if (TickHandlerServer.mothershipData.hasMothershipsInOrbit(body)) {

                float dist = TickHandlerServer.mothershipData.getMothershipOrbitDistanceFor(body);
                float scale = 3.0F * dist * (1.0F / 5.0F);

                if (body instanceof Star) {
                    scale *= 3;
                }

                Vector3f planetPos = this.getCelestialBodyPosition(body);
                GL11.glTranslatef(planetPos.x, planetPos.y, 0);

                float x = scale;
                float y = 0;

                GL11.glBegin(GL11.GL_LINE_LOOP);

                float temp;
                for (int i = 0; i < 90; i++) {
                    GL11.glVertex2f(x, y);

                    temp = x;
                    x = cos * x - sin * y;
                    y = sin * temp + cos * y;
                }

                GL11.glEnd();
            }
        }
        // List<Mothership> msList = TickHandlerServer.mothershipData.getMothershipsForParent(renderShipsAround);
        GL11.glLineWidth(1);
        GL11.glPopMatrix();

        super.drawCircles();

    }

    @Override
    public HashMap<CelestialBody, Matrix4f> drawCelestialBodies(Matrix4f worldMatrix) {
        HashMap<CelestialBody, Matrix4f> result = super.drawCelestialBodies(worldMatrix);
        FloatBuffer fb = BufferUtils.createFloatBuffer(16 * Float.SIZE);

        /*
         * protected CelestialBody lastSelectedBodyMS; protected float mothershipsOrbit; protected int numMotherships;
         * protected float mothershipPhase;
         */

        if (this.selectedBody != null) {
            Matrix4f worldMatrix0 = new Matrix4f(worldMatrix);

            CelestialBody renderShipsAround = null;

            /*
             * render them if: - renderShipsAround == lastSelectedBody - renderShipsAround's parent == lastSelectedBody
             * - renderShipsAround == lastSelectedBody's parent
             */

            renderShipsAround = getBodyToRenderMothershipsAround();
            if (renderShipsAround != null) {

                // MothershipWorldData msData = TickHandlerServer.mothershipData;
                List<Mothership> msList = TickHandlerServer.mothershipData.getMothershipsForParent(renderShipsAround);
                // int numShips = msList.size();

                // if selectionCount > 0 && this.selectedBody instanceof mothership, also render the moon
                // use it on matrix0?
                if (this.selectionCount > 0 && renderShipsAround instanceof Moon
                        && this.selectedBody instanceof Mothership) {
                    _workaroundDrawMoon(worldMatrix0, (Moon) renderShipsAround, fb, result);
                }

                for (Mothership ms : msList) {
                    GL11.glPushMatrix();
                    Matrix4f worldMatrix1 = new Matrix4f(worldMatrix0);
                    Matrix4f.translate(this.getCelestialBodyPosition(ms), worldMatrix1, worldMatrix1);

                    Matrix4f worldMatrix2 = new Matrix4f();
                    Matrix4f.rotate((float) Math.toRadians(45), new Vector3f(0, 0, 1), worldMatrix2, worldMatrix2);
                    Matrix4f.rotate((float) Math.toRadians(-55), new Vector3f(1, 0, 0), worldMatrix2, worldMatrix2);
                    Matrix4f.scale(new Vector3f(0.25F, 0.25F, 1.0F), worldMatrix2, worldMatrix2);
                    worldMatrix2 = Matrix4f.mul(worldMatrix1, worldMatrix2, worldMatrix2);

                    fb.rewind();
                    worldMatrix2.store(fb);
                    fb.flip();
                    GL11.glMultMatrix(fb);

                    CelestialBodyRenderEvent.Pre preEvent = new CelestialBodyRenderEvent.Pre(ms, ms.getBodyIcon(), 8);
                    MinecraftForge.EVENT_BUS.post(preEvent);

                    GL11.glColor4f(1, 1, 1, 1);
                    if (preEvent.celestialBodyTexture != null) {
                        this.mc.renderEngine.bindTexture(preEvent.celestialBodyTexture);
                    }

                    if (!preEvent.isCanceled()) {
                        int size = this.getWidthForMothershipStatic(ms);
                        this.drawTexturedModalRect(
                                -size / 2,
                                -size / 2,
                                size,
                                size,
                                0,
                                0,
                                preEvent.textureSize,
                                preEvent.textureSize,
                                false,
                                false,
                                preEvent.textureSize,
                                preEvent.textureSize);
                        result.put(ms, worldMatrix1);
                    }

                    CelestialBodyRenderEvent.Post postEvent = new CelestialBodyRenderEvent.Post(ms);
                    MinecraftForge.EVENT_BUS.post(postEvent);
                    fb.clear();
                    GL11.glPopMatrix();

                }
            }
        }

        return result;
    }

    public static int getWidthForMothershipStatic(Mothership celestialBody) {
        // CelestialBody parent = celestialBody.getParent();
        // boolean isScreenWtf = false;
        if (Minecraft.getMinecraft().currentScreen instanceof GuiShuttleSelection
                && (celestialBody != ((GuiShuttleSelection) Minecraft.getMinecraft().currentScreen).selectedBody
                        || ((GuiShuttleSelection) Minecraft.getMinecraft().currentScreen).selectionCount != 1)) {
            // isScreenWtf = true;
            return 4;
            // return 6;
        }
        return 6;
        /*
         * if(parent instanceof Star) { // like planet return isScreenWtf ? 4 : 6; } if(parent instanceof Planet) { //
         * like moon return isScreenWtf ? 4 : 6; } if() return celestialBody instanceof Star ? 8 : (celestialBody
         * instanceof Planet ? 4 : (celestialBody instanceof IChildBody ? 4 : (celestialBody instanceof Satellite ? 4 :
         * 2))); return celestialBody instanceof Star ? 12 : (celestialBody instanceof Planet ? 6 : (celestialBody
         * instanceof IChildBody ? 6 : (celestialBody instanceof Satellite ? 6 : 2)));
         */
        // return 2;
    }

    public void mothershipListUpdated() {
        // remove all the ships from the tick list
        for (Iterator<Entry<CelestialBody, Integer>> it = this.celestialBodyTicks.entrySet().iterator(); it
                .hasNext();) {
            Entry<CelestialBody, Integer> entry = it.next();
            if (entry.getKey() instanceof Mothership) {
                it.remove();
            }
        }
        // fill the new data in
        MothershipWorldData msData = TickHandlerServer.mothershipData;
        for (Mothership ms : msData.getMotherships().values()) {
            this.celestialBodyTicks.put(ms, 0);
        }

        updateNumPlayerMotherships();
    }

    public void mothershipCreationFailed() {

    }

    public void newMothershipCreated(Mothership ship) {
        this.celestialBodyTicks.put(ship, 0);
        this.shuttlePossibleBodies.add(ship);
        updateNumPlayerMotherships();
    }

    public void mothershipPositionChanged(Mothership ship) {
        // check if the ship just arrived or left
        if (ship.isInTransit()) {
            // left
            // check if it even affects me
            if (shuttlePossibleBodies.remove(ship)) {
                // apparently it did. do more stuff
                if (this.selectedBody.equals(ship)) {
                    this.unselectCelestialBody();
                }
            }
        } else {
            // arrived
            // I think it SHOULD be in celestialBodyTicks already...
            if (!this.shuttlePossibleBodies.contains(ship)) {
                this.shuttlePossibleBodies.add(ship);
            }
        }
    }

    @Override
    protected Vector3f getCelestialBodyPosition(CelestialBody cBody) {
        if (cBody instanceof Mothership) {
            // failsafe against a possible race condition
            int cBodyTicks = 0;
            if (this.celestialBodyTicks.get(cBody) != null) {

                cBodyTicks = this.celestialBodyTicks.get(cBody);
            }
            float timeScale = 2.0F;
            float distanceFromCenter = this.getScale(cBody);
            float orbitTime = 1 / 0.01F;// 5.0F;

            CelestialBody msParent = ((Mothership) cBody).getParent();
            if (msParent instanceof Star) {
                distanceFromCenter *= 3;
            }

            Vector3f cBodyPos = new Vector3f(
                    (float) Math.sin(cBodyTicks / (timeScale * orbitTime) + cBody.getPhaseShift()) * distanceFromCenter,
                    (float) Math.cos(cBodyTicks / (timeScale * orbitTime) + cBody.getPhaseShift()) * distanceFromCenter,
                    0);

            Vector3f parentVec = this.getCelestialBodyPosition(((Mothership) cBody).getParent());
            return Vector3f.add(cBodyPos, parentVec, null);
        }

        return super.getCelestialBodyPosition(cBody);
    }

    protected void updatePlayerParent() {
        //
        CelestialBody body = ShuttleTeleportHelper
                .getCelestialBodyForDimensionID(this.mc.thePlayer.worldObj.provider.dimensionId);
        if (body instanceof Mothership) {
            body = ((Mothership) body).getParent();
        }
        this.playerParent = body;
    }

    protected void updateNumPlayerMotherships() {

        numPlayersMotherships = TickHandlerServer.mothershipData.getNumMothershipsForPlayer(this.mc.thePlayer);
        // numPlayersMotherships
    }

    @Override
    protected Vector2f getTranslationAdvanced(float partialTicks) {
        /*
         * if (this.selectedBody instanceof Planet && this.lastSelectedBody instanceof IChildBody && ((IChildBody)
         * this.lastSelectedBody).getParentPlanet() == this.selectedBody) { Vector3f posVec =
         * this.getCelestialBodyPosition(this.selectedBody); return new Vector2f(posVec.x, posVec.y); }
         */
        if (this.selectedBody != null) {
            if (this.selectedBody instanceof Mothership) {
                CelestialBody parent = ((Mothership) this.selectedBody).getParent();
                Vector3f result;
                if (parent instanceof IChildBody) {
                    result = this.getCelestialBodyPosition(((IChildBody) parent).getParentPlanet());
                    return new Vector2f(result.x, result.y);
                }
                result = this.getCelestialBodyPosition(parent);
                return new Vector2f(result.x, result.y);
            }
            if (this.selectedBody instanceof Planet && this.lastSelectedBody instanceof Mothership
                    && ((Mothership) this.lastSelectedBody).getParent() == this.selectedBody) {
                Vector3f posVec = this.getCelestialBodyPosition(this.selectedBody);
                return new Vector2f(posVec.x, posVec.y);
            }
        }
        return super.getTranslationAdvanced(partialTicks);
    }

    public void selectAndZoom(CelestialBody target) {
        this.lastSelectedBody = this.selectedBody;
        this.selectedBody = target;
        if (this.lastSelectedBody instanceof IChildBody) {
            this.selectionCount = 1;
        } else {
            this.selectionCount = 2;
        }
        this.preSelectZoom = this.zoom;
        this.preSelectPosition = this.position;
        this.ticksSinceSelection = 0;
    }

    public void selectAndZoomNextTick(CelestialBody target) {
        nextSelectedBody = target;
    }

    @Override
    protected void mouseClicked(int x, int y, int button) {
        if (this.isMessageShown) {
            if (messageButtonBox.isWithin(x, y)) {
                hideMessage();
            }
            return;
        }
        // hackfix for mothership parent selection
        CelestialBody prevSelection = this.selectedBody;
        // int prevTicksSelection = this.ticksSinceSelection;
        // int prevTicksUnSelection = this.ticksSinceUnselection;
        super.mouseClicked(x, y, button);
        if (prevSelection instanceof Mothership && this.selectedBody != prevSelection) {
            // not sure why, but...
            if (prevSelection instanceof IChildBody) {
                this.selectionCount = 1;
            } else {
                this.selectionCount = 2;
            }
            this.lastSelectedBody = prevSelection;
            this.preSelectZoom = this.zoom;
            this.preSelectPosition = this.position;
            this.ticksSinceSelection = 0;
            // this.ticksSinceUnselection = prevTicksUnSelection;
            // this.ticksSinceSelection = prevTicksSelection;
            this.doneZooming = false;
        }

    }

    @Override
    public void updateScreen() {
        if (nextSelectedBody != null) {
            this.selectAndZoom(nextSelectedBody);
            nextSelectedBody = null;
        }
        super.updateScreen();
    }

    public void showMessageBox(String caption, String text) {
        isMessageShown = true;
        messageCaption = caption;
        messageText = text;
    }

    public void hideMessage() {
        isMessageShown = false;
    }

}
